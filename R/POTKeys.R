GenOverlapKey <- function(moltenDischarge,
                          hospKey,
                          msdrgKey,
                          overlapNames=list(),
                          overlapSysNames=list(),
                          overlapDefinition) {
  #
  # 
  #
  # Args:
  #   moltenDischarge: the result of the MeltDischarges function
  #   hospKey: a data frame key of hospital ids and names
  #   msdrgKey: a data frame key of MSDRG information
  #   overlapNames: A list whose length is the number of systems used to define
  #     the overlap, and whose values are each a list (not a vector) of
  #     hospital names to included in that system.
  #   overlapSysNames: Ordered the same as overlapNames, overlapSysNames is a
  #     list whose length is the number of systems used to define the overlap
  #     and whose values are the names of the hospital systems.
  #   overlapDefinition: A function called on a vector of discharges for each
  #     MSDRG. The function must return a one if the MSDRG is to be considered
  #     part of the overlap and a 0 if the MSDRG should be excluded from the
  #     overlap.
  #
  # Returns:
  #   

  # constructing id vectors
  overlapIds <- list()
  if (length(overlapNames)) {
    for (i in c(1:length(overlapNames))) {
      overlapIds[[i]] <- LookupIdByName(hospKey, overlapNames[[i]])
    }
  }
  otherIds <- list()
  if (length(otherNames)) {
    for (i in c(1:length(otherNames))) {
      otherIds[[i]] <- LookupIdByName(hospKey, otherNames[[i]])
    }
  }
  # casting for an msdrg table with all discharges
  subset <- moltenDischarge[, c('discharge_id', 'msdrg', 'hosp_id', 'variable', 'value')]
  casted <- dcast(subset, msdrg ~ hosp_id, sum)

  # generating a 
  result <- msdrgKey[, c('msdrg', 'msdrg_title', 'msdrg_type', 'ei_def', 'ei_mdc')]
  total <- data.frame(msdrg=msdrgKey$msdrg)
  for (i in 1:length(overlapIds)) {
    sysName <- paste(overlapSysNames[i], "_Total", sep="")
    sys <- data.frame(msdrg=casted[, c('msdrg')], GroupSystem(casted, overlapIds[[i]], sysName))
    result <- merge(result, sys, by='msdrg', all=TRUE, sort=TRUE)
    total <- merge(total, sys[, c(1, length(sys))], by='msdrg', all=TRUE, sort=TRUE)
  }
  if (length(overlapIds)) {
    overlap <- apply(as.matrix(total[, !names(total)%in%c('msdrg')]), 1, FUN=overlapDefinition)
  }
  for (i in otherIds) {
    sysName <- paste(otherSysNames[i], "_Total", sep="")
    sys <- data.frame(msdrg=casted[, c('msdrg')], GroupSystem(casted, otherIds[[i]], sysName))
    result <- merge(result, sys, by='msdrg', sort=FALSE, all=TRUE)
    total <- merge(total, sys[, c(1, length(sys))], by='msdrg', sort=FALSE, all=TRUE)
  }
  relTotal <- apply(as.matrix(total[, !names(total)%in%c('msdrg')]), 1, sum)  
  result <- cbind(result, System_Total=relTotal, Overlap=overlap)
  return(result)
}

GenPayerKey <- function(moltenDischarge, commercialPayers) {
  #
  # Returns a key of commercial payers, to be used as input for the
  # CastDischarge function
  #
  # Args:
  #   moltenDischarge: the molten discharge data, output of MeltDischarge
  #   commercialPayers: a vector commercial payers, specified by the payer_d
  #     field
  #
  # Returns:
  #   a data frame containing the payer descriptions and a dummy flagging
  #   commercial payers
  
  uniquePayers <- unique(moltenDischarge['payer'])
  commercialDummy <- lapply(uniquePayers, function(x){
                              as.numeric(x %in% commercialPayers)
                            })
  names(commercialDummy) <- c('commercial')
  result <- data.frame(uniquePayers, commercialDummy)
  return(result)
}

GenHospKey <- function() {
  
}

LookupIdByName <- function(hospKey, hospNames) {
  #
  # Returns a vector of ids corresponding to names in hospNames
  #
  # Args:
  #   hospKey: the hospital name/id key generated by GenHospKey
  #   hospNames: a vector of hospital names
  #
  # Returns: 
  #   A vector of hospital ids matching the names in hospNames. Unmatched names
  #   return an Error
  
  subset <- hospKey[hospKey$hosp_name %in% hospNames, ]
  ids <- subset$hosp_id
  if (length(ids) != length(hospNames)) {
    warning("One or more hospital names could not be found in the input key.")
  }
  return(ids)
}

